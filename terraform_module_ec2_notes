Module development 
==================
Module will works on DRY principle --- Dont repeat yourself

Important points 
variables
functions

min code 
code reuse


write resource defintions
left side options are from documentation,you can't change options right side are values,
we can give as per project requirement 
keep variables and their default values 
override if required

resource defintion
------------------
resource "aws_instance" "" {
}

left side options
----------------
ami
instance_type 


So by using module concept we are creating ec2 instance 

first we are giving leftside values in resource
resource "aws_instance" "db" {
    ami = 
    instance_type = 
    vpc_security_group_ids = 
	tags = {
      
    }

Now we are creating variables for left side values

variable "ami_id" {
    type = string
    default = "ami-041e2ea9402c46c32"
  
}

variable "security_group_ids" {
    type = list
    default = ["sg-0d691bc690171d377"]
  
}
variable "instance_type" {
    #type = string      #dont mention type for instance_type, we will get an error
    default = "t3.micro"
  
}

variable "tags" {
    type = map 
    default = {} #this means empty, its not a mandatory 
  
}

so after creation of variables we assigning to the values to the resource

resource "aws_instance" "db" {
    ami = var.ami_id
    instance_type = var.instance_type
    vpc_security_group_ids = var.security_group_ids
    tags = var.tags
}

Note: providers.tf still we dint not use in this directory
we created resource and we defined variables

so we can create one more directory and we will create providers.tf 

code placed in one directory and we have to use the one more directory
we can called the code by using "module"
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "5.48.0"
    }
  }
  backend "s3" {
    bucket = "nag-devops1"
    key    = "module-ec2"     #we need to change the key value 
    region = "us-east-1"
    dynamodb_table = "nag-locking"
  }
}

#provide authentication here
provider "aws" {
  region = "us-east-1"
}

	
  
}


after that we can create file ec2.tf

we have to call the code by using module

module "ec2-test" {

#provide code directory to call the code , we can use the source command 

source = "../terraform-aws-ec2"
}

so we can run the terraform commands 

$ terraform init
Initializing modules...
- ec2-test in ..\terraform-aws-ec2

Initializing the backend...

Successfully configured the backend "s3"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...
- Finding hashicorp/aws versions matching "5.48.0"...
- Installing hashicorp/aws v5.48.0...

once terraform init completed automatically "module" will be created 
in that "module.json" automatically created its contains the terraform code details 

so it will call the code and its will create the ec2 instance

if you want override default values 

module "aws-ec2" {

source = "../terraform-aws-ec2"
instance_type = "t3.small"  #its will override the t3.micro
tags = {
Name = "Module-test"
terraform = "true"
  }
}

advantages
-----------
code reuse 
best practices can be implemente and force to use 
easy to maintain/update
we can keep few restrictions based on company guidelines

module developers --- they create tf code with best practices
module users -- they can use the code 
 
module are two types
===================
1.custom module development
2.open source modules

VPC()
=======
virtual private cloud 
suppose we have a project
they have to buy the servers
deploy the code in servers
development ---- only dev servers
testing --- only qa servers
production support --- limited access for production servers 
call center --- only internal applications
devops --- full access to all servers 
linux admin -- all server access 

data center
==========
space
watchmen
network 
resources
maintanance 
logical seperation of servers
power

VPC
=====
VPC is a mini data center for a project.
resources created inside VPC are isolated and private to ourself

VPC name = village name 
VPC CIDR = village pincode 
subnets = streets 
arch = internet gateway 
routes = roads 

public and private subnets
----------------------------
subnets which are connected to internet gateway are called public subnets
subnets which are not connected to internet gateway are called private subnets

10.0.0.0/16 ------> first 2 digits are fixed, your are not allowed to change , you can change last 2 octate
10.0 -----> fixed 
each octate range -- 0-255 

10.0.1.0/24 -----> first 3 digits are fixed, you can change last octate 

10.0.2.0/24,10.0.3.0/24,10.0.3.0/24,


steps
=======
first we have to created VPC with CIDR ----10.0.0.0/24
based on VPC 
we have to create VPC subnets 
public subnets ---10.0.1.0/24 
private subnets ----- 10.0.11.0/24 

next we have to create internet gateway and attach internet gateway to VPC 

create route tables
public route table and attach VPC
private route table and attach VPC 

frontend ---- public
backend ----- private
db ------ private, we create in db subnet 

what is high availability zone 
------------------------------
suppose we have availability zones 1a,1b
suppose will 1a down ----1b be will available 

if two 1a,1b availability zones are up---the traffic will be moved to 1a,1b 

2 subnets ---> 1a and 1b 
2 private subnets ----> 1a and 1b 
2 db subnets --1a and 1b 

VPC
---
create VPC
create IGW 
attach IGW to VPC 
create subnet
create route table 
create routes 
attach route table subnet


create VPC
----------
create the VPC -----with CIDR  ----10.0.0.0./16 

IGW
----
create IGW ----with name expense --- and attach VPC to IGW 

